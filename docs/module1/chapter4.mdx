---
id: chapter4
sidebar_position: 4
---

# Building Real ROS 2 Packages in Python (rclpy)

## Overview

This chapter covers the fundamentals of building real ROS 2 packages using Python and the rclpy client library. You'll learn how to create professional-grade ROS 2 packages that follow best practices and can be integrated into larger robotic systems.

## Learning Objectives

By the end of this chapter, you will be able to:
- Create ROS 2 packages with proper structure and dependencies
- Implement ROS 2 nodes using rclpy
- Design custom messages and services
- Package and distribute your ROS 2 code
- Debug and test ROS 2 packages effectively

## Package Structure

A well-structured ROS 2 package follows a specific directory layout that enables proper build processes and dependency management. The basic structure includes:

- `package.xml`: Package manifest with metadata and dependencies
- `setup.py`: Python setup configuration
- `setup.cfg`: Installation configuration
- `src/`: Source code directory
- `test/`: Unit and integration tests
- `launch/`: Launch files for running nodes
- `config/`: Configuration files

## Creating Your First ROS 2 Package

Let's create a practical ROS 2 package that demonstrates the core concepts of node development, topic communication, and service calls.

### Package Manifest (package.xml)

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>robot_control_examples</name>
  <version>0.0.0</version>
  <description>Examples for ROS 2 robot control</description>
  <maintainer email="user@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <depend>rclpy</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

### Setup Configuration (setup.py)

```python
from setuptools import setup
from glob import glob
import os

package_name = 'robot_control_examples'

setup(
    name=package_name,
    version='0.0.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Your Name',
    maintainer_email='user@example.com',
    description='Examples for ROS 2 robot control',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'simple_publisher = robot_control_examples.simple_publisher:main',
            'simple_subscriber = robot_control_examples.simple_subscriber:main',
        ],
    },
)
```

## Practical Example: Robot Command Publisher

Let's build a practical example that publishes robot commands to control a simulated humanoid robot:

```python
# robot_control_examples/robot_command_publisher.py
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from std_msgs.msg import String
import time

class RobotCommandPublisher(Node):
    def __init__(self):
        super().__init__('robot_command_publisher')
        self.publisher = self.create_publisher(Twist, 'cmd_vel', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = Twist()
        msg.linear.x = float(self.i % 10) / 10.0  # Vary linear velocity
        msg.angular.z = float(self.i % 8) / 10.0  # Vary angular velocity
        self.publisher.publish(msg)
        self.get_logger().info(f'Publishing: linear={msg.linear.x}, angular={msg.angular.z}')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    robot_command_publisher = RobotCommandPublisher()
    rclpy.spin(robot_command_publisher)
    robot_command_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Advanced Topics

This chapter will also cover advanced topics such as:

- Custom message definitions and usage
- Action servers and clients for complex behaviors
- Parameter management and dynamic reconfiguration
- Lifecycle nodes for robust system management
- Integration with ROS 2 tools like rqt and rviz

## Exercises

1. Create a ROS 2 package that publishes sensor data from a simulated humanoid robot
2. Implement a service that allows remote control of robot joints
3. Design a custom message type for humanoid robot pose commands

## Project

Develop a complete ROS 2 package that implements a simple humanoid robot controller with both publisher and subscriber nodes, following all ROS 2 best practices and including proper testing and documentation.