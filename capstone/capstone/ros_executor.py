#!/usr/bin/env python3

"""
ROS Executor Node for Capstone Project

This node executes task plans generated by the LLM planner using ROS 2 actions and services.
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile
from rclpy.action import ActionClient
from rclpy.callback_groups import ReentrantCallbackGroup

from std_msgs.msg import String
from geometry_msgs.msg import PoseStamped, Point
from nav_msgs.msg import Path
from sensor_msgs.msg import JointState
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from control_msgs.action import FollowJointTrajectory
from moveit_msgs.action import MoveGroup
from capstone_interfaces.msg import TaskPlan, ExecutionStatus  # Assuming custom message types

import time
import json
from enum import Enum
from threading import Lock


class ExecutionState(Enum):
    """Enumeration for execution states"""
    IDLE = 0
    EXECUTING = 1
    PAUSED = 2
    ERROR = 3
    COMPLETED = 4


class ROSExecutorNode(Node):
    """
    A node that executes task plans using ROS 2 actions and services.
    """

    def __init__(self):
        super().__init__('ros_executor')

        # Initialize execution state
        self.current_state = ExecutionState.IDLE
        self.current_plan = None
        self.current_step_index = 0
        self.execution_lock = Lock()

        # Publishers and subscribers
        qos_profile = QoSProfile(depth=10)

        self.plan_sub = self.create_subscription(
            TaskPlan,
            'task_plan',
            self.plan_callback,
            qos_profile
        )

        self.status_pub = self.create_publisher(
            ExecutionStatus,
            'execution_status',
            qos_profile
        )

        self.feedback_pub = self.create_publisher(
            String,
            'execution_feedback',
            qos_profile
        )

        # Action clients for different robot capabilities
        self.nav_client = ActionClient(
            self,
            MoveGroup,
            'move_group',
            callback_group=ReentrantCallbackGroup()
        )

        self.trajectory_client = ActionClient(
            self,
            FollowJointTrajectory,
            'joint_trajectory_controller/follow_joint_trajectory',
            callback_group=ReentrantCallbackGroup()
        )

        # Service clients
        self.perception_client = self.create_client(
            # Assuming a custom service for object detection
            'detect_objects',
            'detect_objects'
        )

        # Timers
        self.execution_timer = self.create_timer(0.1, self.execution_loop)

        # Robot-specific parameters
        self.joint_names = [
            'left_hip_roll', 'left_hip_yaw', 'left_hip_pitch',
            'left_knee', 'left_ankle_pitch', 'left_ankle_roll',
            'right_hip_roll', 'right_hip_yaw', 'right_hip_pitch',
            'right_knee', 'right_ankle_pitch', 'right_ankle_roll',
            'left_shoulder_roll', 'left_shoulder_pitch', 'left_shoulder_yaw',
            'left_elbow', 'left_wrist_pitch', 'left_wrist_yaw',
            'right_shoulder_roll', 'right_shoulder_pitch', 'right_shoulder_yaw',
            'right_elbow', 'right_wrist_pitch', 'right_wrist_yaw'
        ]

        self.get_logger().info('ROS Executor node initialized')

    def plan_callback(self, msg):
        """
        Callback for task plans
        """
        self.get_logger().info(f'Received task plan with {len(msg.steps)} steps')

        with self.execution_lock:
            if self.current_state != ExecutionState.IDLE:
                self.get_logger().warn('Executor busy, rejecting new plan')
                return

            self.current_plan = msg
            self.current_step_index = 0
            self.current_state = ExecutionState.EXECUTING

            self.get_logger().info('Started executing new task plan')

    def execution_loop(self):
        """
        Main execution loop
        """
        if self.current_state != ExecutionState.EXECUTING or self.current_plan is None:
            return

        if self.current_step_index >= len(self.current_plan.steps):
            # Plan completed
            self.current_state = ExecutionState.COMPLETED
            self.publish_status(ExecutionState.COMPLETED, "Plan completed successfully")
            self.current_plan = None
            return

        # Execute current step
        current_step = self.current_plan.steps[self.current_step_index]
        success = self.execute_step(current_step)

        if success:
            self.get_logger().info(f'Step {self.current_step_index} completed: {current_step.description}')
            self.current_step_index += 1

            if self.current_step_index >= len(self.current_plan.steps):
                # Plan completed
                self.current_state = ExecutionState.COMPLETED
                self.publish_status(ExecutionState.COMPLETED, "Plan completed successfully")
                self.current_plan = None
        else:
            # Execution failed
            self.current_state = ExecutionState.ERROR
            self.publish_status(ExecutionState.ERROR, f"Step {self.current_step_index} failed: {current_step.description}")
            self.current_plan = None

    def execute_step(self, step):
        """
        Execute a single step of the plan
        """
        try:
            self.get_logger().info(f'Executing step: {step.description}')

            # Publish feedback
            feedback_msg = String()
            feedback_msg.data = f'Executing: {step.description}'
            self.feedback_pub.publish(feedback_msg)

            # Parse parameters from JSON
            params = json.loads(step.parameters) if step.parameters else {}

            # Execute based on action type
            if step.action_type == 'navigation':
                return self.execute_navigation(params)
            elif step.action_type == 'manipulation':
                return self.execute_manipulation(params)
            elif step.action_type == 'perception':
                return self.execute_perception(params)
            elif step.action_type == 'planning':
                return self.execute_planning(params)
            elif step.action_type == 'localization':
                return self.execute_localization(params)
            elif step.action_type == 'verification':
                return self.execute_verification(params)
            elif step.action_type == 'safety':
                return self.execute_safety_check(params)
            else:
                self.get_logger().error(f'Unknown action type: {step.action_type}')
                return False

        except Exception as e:
            self.get_logger().error(f'Error executing step {step.id}: {e}')
            return False

    def execute_navigation(self, params):
        """
        Execute navigation action
        """
        try:
            destination = params.get('destination', 'unknown')
            self.get_logger().info(f'Navigating to: {destination}')

            # In a real implementation, this would call navigation actions
            # For demonstration, we'll just simulate the navigation
            time.sleep(2.0)  # Simulate navigation time

            self.get_logger().info(f'Navigation to {destination} completed')
            return True

        except Exception as e:
            self.get_logger().error(f'Navigation error: {e}')
            return False

    def execute_manipulation(self, params):
        """
        Execute manipulation action
        """
        try:
            object_name = params.get('object', 'unknown')
            action = params.get('action', 'manipulate')
            self.get_logger().info(f'Performing {action} on {object_name}')

            # In a real implementation, this would call manipulation actions
            # For demonstration, we'll just simulate the manipulation
            time.sleep(3.0)  # Simulate manipulation time

            self.get_logger().info(f'Manipulation of {object_name} completed')
            return True

        except Exception as e:
            self.get_logger().error(f'Manipulation error: {e}')
            return False

    def execute_perception(self, params):
        """
        Execute perception action
        """
        try:
            object_type = params.get('object_type', 'unknown')
            self.get_logger().info(f'Detecting object of type: {object_type}')

            # In a real implementation, this would call perception services
            # For demonstration, we'll just simulate perception
            time.sleep(1.0)  # Simulate perception time

            self.get_logger().info(f'Perception of {object_type} completed')
            return True

        except Exception as e:
            self.get_logger().error(f'Perception error: {e}')
            return False

    def execute_planning(self, params):
        """
        Execute planning action
        """
        try:
            destination = params.get('destination', 'unknown')
            self.get_logger().info(f'Planning path to: {destination}')

            # In a real implementation, this would call planning services
            # For demonstration, we'll just simulate planning
            time.sleep(0.5)  # Simulate planning time

            self.get_logger().info(f'Path planning to {destination} completed')
            return True

        except Exception as e:
            self.get_logger().error(f'Planning error: {e}')
            return False

    def execute_localization(self, params):
        """
        Execute localization action
        """
        try:
            self.get_logger().info('Localizing robot in environment')

            # In a real implementation, this would call localization services
            # For demonstration, we'll just simulate localization
            time.sleep(1.0)  # Simulate localization time

            self.get_logger().info('Localization completed')
            return True

        except Exception as e:
            self.get_logger().error(f'Localization error: {e}')
            return False

    def execute_verification(self, params):
        """
        Execute verification action
        """
        try:
            location = params.get('location', 'unknown')
            self.get_logger().info(f'Verifying location: {location}')

            # In a real implementation, this would call verification services
            # For demonstration, we'll just simulate verification
            time.sleep(0.5)  # Simulate verification time

            self.get_logger().info(f'Verification of {location} completed')
            return True

        except Exception as e:
            self.get_logger().error(f'Verification error: {e}')
            return False

    def execute_safety_check(self, params):
        """
        Execute safety check action
        """
        try:
            check_type = params.get('check_type', 'general')
            self.get_logger().info(f'Performing safety check: {check_type}')

            # In a real implementation, this would check safety systems
            # For demonstration, we'll just simulate safety check
            time.sleep(0.2)  # Simulate safety check time

            self.get_logger().info(f'Safety check {check_type} completed')
            return True

        except Exception as e:
            self.get_logger().error(f'Safety check error: {e}')
            return False

    def publish_status(self, state, message):
        """
        Publish execution status
        """
        status_msg = ExecutionStatus()
        status_msg.header.stamp = self.get_clock().now().to_msg()
        status_msg.state = state.value
        status_msg.message = message
        status_msg.progress = self.current_step_index / len(self.current_plan.steps) if self.current_plan else 0.0

        self.status_pub.publish(status_msg)

    def reset_execution(self):
        """
        Reset execution state
        """
        with self.execution_lock:
            self.current_state = ExecutionState.IDLE
            self.current_plan = None
            self.current_step_index = 0


def main(args=None):
    rclpy.init(args=args)

    ros_executor = ROSExecutorNode()

    try:
        rclpy.spin(ros_executor)
    except KeyboardInterrupt:
        pass
    finally:
        ros_executor.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()