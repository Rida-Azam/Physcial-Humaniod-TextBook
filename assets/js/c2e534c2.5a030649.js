"use strict";(self.webpackChunkphysical_ai_textbook=self.webpackChunkphysical_ai_textbook||[]).push([[68],{5634:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var s=i(4848),t=i(8453);const o={id:"chapter6",sidebar_position:1,title:"Simulation Fundamentals \u2013 Gazebo Harmonic & Physics Engines"},a="Chapter 6: Simulation Fundamentals \u2013 Gazebo Harmonic & Physics Engines",l={id:"module2/chapter6",title:"Simulation Fundamentals \u2013 Gazebo Harmonic & Physics Engines",description:"Learning Objectives",source:"@site/docs/module2/chapter6.mdx",sourceDirName:"module2",slug:"/module2/chapter6",permalink:"/physical-ai-textbook/docs/module2/chapter6",draft:!1,unlisted:!1,editUrl:"https://github.com/your-github-username/physical-ai-textbook/tree/main/docs/module2/chapter6.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"chapter6",sidebar_position:1,title:"Simulation Fundamentals \u2013 Gazebo Harmonic & Physics Engines"},sidebar:"tutorialSidebar",previous:{title:"URDF & Robot Description Mastery",permalink:"/physical-ai-textbook/docs/module1/chapter5"},next:{title:"NVIDIA Isaac Sim \u2013 The New Standard for Humanoid Training",permalink:"/physical-ai-textbook/docs/module2/chapter7"}},r={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"6.1 Introduction to Robot Simulation",id:"61-introduction-to-robot-simulation",level:2},{value:"6.1.1 Benefits of Simulation",id:"611-benefits-of-simulation",level:3},{value:"6.1.2 Simulation Challenges for Humanoid Robots",id:"612-simulation-challenges-for-humanoid-robots",level:3},{value:"6.2 Gazebo Harmonic Overview",id:"62-gazebo-harmonic-overview",level:2},{value:"6.2.1 Key Features",id:"621-key-features",level:3},{value:"6.2.2 Installation and Setup",id:"622-installation-and-setup",level:3},{value:"6.3 Physics Engine Fundamentals",id:"63-physics-engine-fundamentals",level:2},{value:"6.3.1 Understanding Physics Simulation",id:"631-understanding-physics-simulation",level:3},{value:"6.3.2 Physics Parameters for Humanoid Simulation",id:"632-physics-parameters-for-humanoid-simulation",level:3},{value:"6.3.3 Contact Modeling for Humanoid Locomotion",id:"633-contact-modeling-for-humanoid-locomotion",level:3},{value:"6.4 Setting Up Humanoid Simulation Environments",id:"64-setting-up-humanoid-simulation-environments",level:2},{value:"6.4.1 Environment Design Principles",id:"641-environment-design-principles",level:3},{value:"6.4.2 Creating Simulation Worlds",id:"642-creating-simulation-worlds",level:3},{value:"6.5 Integrating with ROS 2",id:"65-integrating-with-ros-2",level:2},{value:"6.5.1 Gazebo-ROS 2 Bridge",id:"651-gazebo-ros-2-bridge",level:3},{value:"6.5.2 Sensor Integration",id:"652-sensor-integration",level:3},{value:"6.6 Validating Simulation Accuracy",id:"66-validating-simulation-accuracy",level:2},{value:"6.6.1 Sim-to-Real Transfer Challenges",id:"661-sim-to-real-transfer-challenges",level:3},{value:"6.6.2 Validation Techniques",id:"662-validation-techniques",level:3},{value:"6.7 Best Practices for Humanoid Simulation",id:"67-best-practices-for-humanoid-simulation",level:2},{value:"6.7.1 Simulation Optimization",id:"671-simulation-optimization",level:3},{value:"6.7.2 Debugging Simulation Issues",id:"672-debugging-simulation-issues",level:3},{value:"6.8 Summary",id:"68-summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"chapter-6-simulation-fundamentals--gazebo-harmonic--physics-engines",children:"Chapter 6: Simulation Fundamentals \u2013 Gazebo Harmonic & Physics Engines"}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Understand the fundamentals of robot simulation and its role in robotics development"}),"\n",(0,s.jsx)(e.li,{children:"Configure and use Gazebo Harmonic for humanoid robot simulation"}),"\n",(0,s.jsx)(e.li,{children:"Implement physics engines for realistic robot-environment interactions"}),"\n",(0,s.jsx)(e.li,{children:"Design simulation environments that accurately represent real-world scenarios"}),"\n",(0,s.jsx)(e.li,{children:"Validate simulation results against real-world robot behavior"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"61-introduction-to-robot-simulation",children:"6.1 Introduction to Robot Simulation"}),"\n",(0,s.jsx)(e.p,{children:"Robot simulation plays a critical role in the development and testing of robotic systems. It allows for rapid prototyping, algorithm testing, and safety validation before deploying on real hardware. For humanoid robots, simulation is especially valuable due to the complexity and cost of real-world testing."}),"\n",(0,s.jsx)(e.h3,{id:"611-benefits-of-simulation",children:"6.1.1 Benefits of Simulation"}),"\n",(0,s.jsx)(e.p,{children:"Simulation offers several advantages in humanoid robotics development:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Cost Reduction"}),": Eliminates the need for expensive physical prototypes"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Safety"}),": Allows testing of dangerous scenarios without risk to hardware or humans"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Repeatability"}),": Enables consistent testing conditions across experiments"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Speed"}),": Accelerates development cycles by running multiple tests in parallel"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Customization"}),": Ability to modify environments and scenarios easily"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"612-simulation-challenges-for-humanoid-robots",children:"6.1.2 Simulation Challenges for Humanoid Robots"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid robots present unique simulation challenges:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complex Dynamics"}),": Balancing and locomotion require accurate physics modeling"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"High DOF"}),": Many joints increase computational complexity"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Contact Modeling"}),": Foot-ground interactions critical for stability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Real-time Requirements"}),": Need for interactive simulation speeds"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"62-gazebo-harmonic-overview",children:"6.2 Gazebo Harmonic Overview"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo Harmonic represents the latest in the Gazebo family of simulation tools, offering enhanced physics accuracy, rendering capabilities, and integration with ROS 2."}),"\n",(0,s.jsx)(e.h3,{id:"621-key-features",children:"6.2.1 Key Features"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo Harmonic includes several key features beneficial for humanoid simulation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Enhanced Physics Engine"}),": Improved contact modeling and stability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Realistic Rendering"}),": High-quality visual simulation with dynamic lighting"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugin Architecture"}),": Extensible functionality through custom plugins"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ROS 2 Integration"}),": Native support for ROS 2 communication patterns"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Scalability"}),": Support for large-scale environments and multi-robot scenarios"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"622-installation-and-setup",children:"6.2.2 Installation and Setup"}),"\n",(0,s.jsx)(e.p,{children:"To install Gazebo Harmonic with ROS 2 Jazzy:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Install Gazebo Harmonic\nsudo apt-get update\nsudo apt-get install ros-jazzy-gazebo-*\n\n# Verify installation\ngz --versions\n"})}),"\n",(0,s.jsx)(e.h2,{id:"63-physics-engine-fundamentals",children:"6.3 Physics Engine Fundamentals"}),"\n",(0,s.jsx)(e.h3,{id:"631-understanding-physics-simulation",children:"6.3.1 Understanding Physics Simulation"}),"\n",(0,s.jsx)(e.p,{children:"Physics engines in robotics simulation approximate real-world physics through numerical methods. For humanoid robots, the most critical aspects are:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Rigid Body Dynamics"}),": Movement and interaction of solid objects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision Detection"}),": Identifying when objects intersect"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Contact Resolution"}),": Computing forces when objects touch"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Constraint Solving"}),": Maintaining joint relationships and limits"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"632-physics-parameters-for-humanoid-simulation",children:"6.3.2 Physics Parameters for Humanoid Simulation"}),"\n",(0,s.jsx)(e.p,{children:"For accurate humanoid simulation, several parameters require careful tuning:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example physics configuration for humanoid simulation --\x3e\n<physics type="ode">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000</real_time_update_rate>\n  <gravity>0 0 -9.8</gravity>\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>100</iters>\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>0</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"633-contact-modeling-for-humanoid-locomotion",children:"6.3.3 Contact Modeling for Humanoid Locomotion"}),"\n",(0,s.jsx)(e.p,{children:"Accurate contact modeling is crucial for humanoid walking simulation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Foot-Ground Contact"}),": Determines walking stability and balance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Friction Parameters"}),": Affects grip and slipping behavior"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Contact Stiffness"}),": Influences impact response and stability"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"64-setting-up-humanoid-simulation-environments",children:"6.4 Setting Up Humanoid Simulation Environments"}),"\n",(0,s.jsx)(e.h3,{id:"641-environment-design-principles",children:"6.4.1 Environment Design Principles"}),"\n",(0,s.jsx)(e.p,{children:"Effective simulation environments should:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Represent Real Scenarios"}),": Mirror actual deployment environments"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Include Perturbations"}),": Test robot robustness to disturbances"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Provide Ground Truth"}),": Enable accurate performance evaluation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Support Multiple Modalities"}),": Include visual, proprioceptive, and other sensors"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"642-creating-simulation-worlds",children:"6.4.2 Creating Simulation Worlds"}),"\n",(0,s.jsx)(e.p,{children:"A typical humanoid simulation world includes:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example world file structure --\x3e\n<sdf version="1.7">\n  <world name="humanoid_lab">\n    \x3c!-- Include ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Add furniture and obstacles --\x3e\n    <model name="table">\n      <pose>1 0 0 0 0 0</pose>\n      <include>\n        <uri>model://table</uri>\n      </include>\n    </model>\n\n    \x3c!-- Physics configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n    </physics>\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"65-integrating-with-ros-2",children:"6.5 Integrating with ROS 2"}),"\n",(0,s.jsx)(e.h3,{id:"651-gazebo-ros-2-bridge",children:"6.5.1 Gazebo-ROS 2 Bridge"}),"\n",(0,s.jsx)(e.p,{children:"The Gazebo-ROS 2 bridge facilitates communication between simulation and ROS 2:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Example ROS 2 node that interfaces with Gazebo simulation\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import Twist\nfrom gazebo_msgs.srv import SpawnEntity, DeleteEntity\n\nclass GazeboInterface(Node):\n    def __init__(self):\n        super().__init__('gazebo_interface')\n\n        # Publishers for robot control\n        self.joint_pub = self.create_publisher(JointState, '/joint_commands', 10)\n\n        # Subscribers for robot state\n        self.state_sub = self.create_subscription(\n            JointState, '/joint_states', self.state_callback, 10\n        )\n\n        # Service clients for simulation control\n        self.spawn_client = self.create_client(SpawnEntity, '/spawn_entity')\n        self.delete_client = self.create_client(DeleteEntity, '/delete_entity')\n\n    def state_callback(self, msg):\n        \"\"\"Process joint state messages from simulation\"\"\"\n        # Process and use state information\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n    interface = GazeboInterface()\n    rclpy.spin(interface)\n    interface.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(e.h3,{id:"652-sensor-integration",children:"6.5.2 Sensor Integration"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid robots require multiple sensor types in simulation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"IMU Sensors"}),": For balance and orientation information"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force/Torque Sensors"}),": For contact detection and manipulation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Cameras"}),": For visual perception tasks"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"LIDAR"}),": For navigation and mapping"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"66-validating-simulation-accuracy",children:"6.6 Validating Simulation Accuracy"}),"\n",(0,s.jsx)(e.h3,{id:"661-sim-to-real-transfer-challenges",children:"6.6.1 Sim-to-Real Transfer Challenges"}),"\n",(0,s.jsx)(e.p,{children:"Key challenges in sim-to-real transfer include:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Reality Gap"}),": Differences between simulated and real physics"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Noise"}),": Real sensors have different characteristics than simulated ones"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Actuator Dynamics"}),": Real motors behave differently than idealized models"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Environmental Factors"}),": Lighting, floor texture, and other real-world conditions"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"662-validation-techniques",children:"6.6.2 Validation Techniques"}),"\n",(0,s.jsx)(e.p,{children:"To validate simulation accuracy:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Kinematic Validation"}),": Compare joint positions between sim and real"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamic Validation"}),": Compare forces, accelerations, and torques"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Task-Based Validation"}),": Compare task completion rates and strategies"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Statistical Validation"}),": Use metrics to quantify sim-to-real differences"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"67-best-practices-for-humanoid-simulation",children:"6.7 Best Practices for Humanoid Simulation"}),"\n",(0,s.jsx)(e.h3,{id:"671-simulation-optimization",children:"6.7.1 Simulation Optimization"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Appropriate Step Sizes"}),": Balance accuracy with computational efficiency"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Selective Detail"}),": Focus simulation detail on critical components"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Parallel Processing"}),": Use multiple threads where possible"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Caching"}),": Store frequently computed values"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"672-debugging-simulation-issues",children:"6.7.2 Debugging Simulation Issues"}),"\n",(0,s.jsx)(e.p,{children:"Common simulation debugging techniques:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visual Inspection"}),": Use Gazebo's visualization tools"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Logging"}),": Record detailed state information"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Comparative Analysis"}),": Compare with known good configurations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Incremental Testing"}),": Test components individually"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"68-summary",children:"6.8 Summary"}),"\n",(0,s.jsx)(e.p,{children:"Simulation is fundamental to humanoid robotics development, providing a safe and cost-effective environment for testing complex behaviors. Gazebo Harmonic offers powerful tools for creating realistic humanoid simulations, but requires careful configuration to achieve accurate results. The physics engine parameters, contact modeling, and sensor integration all significantly impact simulation fidelity."}),"\n",(0,s.jsx)(e.p,{children:"Successful simulation requires balancing computational efficiency with physical accuracy, while maintaining awareness of the sim-to-real transfer challenges that may arise."}),"\n",(0,s.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Set up a basic humanoid robot model in Gazebo Harmonic and test its joint control."}),"\n",(0,s.jsx)(e.li,{children:"Configure physics parameters to achieve stable standing behavior for a humanoid model."}),"\n",(0,s.jsx)(e.li,{children:"Create a simple navigation environment and test path planning algorithms in simulation."}),"\n",(0,s.jsx)(e.li,{children:"Compare simulation results with analytical models of humanoid dynamics."}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Gazebo Harmonic Documentation. (2024). Open Source Robotics Foundation."}),"\n",(0,s.jsx)(e.li,{children:'Coumans, E., & Bai, Y. (2016). "PyBullet, a Python module for physics simulation for games, robotics and machine learning."'}),"\n",(0,s.jsx)(e.li,{children:'Tedrake, R. (2009). "Underactuated Robotics: Algorithms for Walking, Running, Swimming, Flying, and Manipulation."'}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>l});var s=i(6540);const t={},o=s.createContext(t);function a(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),s.createElement(o.Provider,{value:e},n.children)}}}]);