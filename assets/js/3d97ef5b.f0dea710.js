"use strict";(self.webpackChunkphysical_ai_textbook=self.webpackChunkphysical_ai_textbook||[]).push([[54],{1782:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var t=i(4848),s=i(8453);const o={id:"chapter3",sidebar_position:3,title:"ROS 2 Architecture Deep Dive"},r="Chapter 3: ROS 2 Architecture Deep Dive",c={id:"module1/chapter3",title:"ROS 2 Architecture Deep Dive",description:"This chapter provides a comprehensive overview of the Robot Operating System 2 (ROS 2) architecture, focusing on its core concepts: nodes, topics, services, and actions. We will explore how these components facilitate communication and coordination in robotic systems, particularly for humanoid robots.",source:"@site/docs/module1/chapter3.mdx",sourceDirName:"module1",slug:"/module1/chapter3",permalink:"/physical-ai-textbook/docs/module1/chapter3",draft:!1,unlisted:!1,editUrl:"https://github.com/your-github-username/physical-ai-textbook/tree/main/docs/module1/chapter3.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"chapter3",sidebar_position:3,title:"ROS 2 Architecture Deep Dive"},sidebar:"tutorialSidebar",previous:{title:"The Humanoid Landscape 2025\u20132030",permalink:"/physical-ai-textbook/docs/module1/chapter2"},next:{title:"Building Real ROS 2 Packages in Python (rclpy)",permalink:"/physical-ai-textbook/docs/module1/chapter4"}},a={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"3.1 Nodes, Topics, Services, and Actions",id:"31-nodes-topics-services-and-actions",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"chapter-3-ros-2-architecture-deep-dive",children:"Chapter 3: ROS 2 Architecture Deep Dive"}),"\n",(0,t.jsx)(n.p,{children:"This chapter provides a comprehensive overview of the Robot Operating System 2 (ROS 2) architecture, focusing on its core concepts: nodes, topics, services, and actions. We will explore how these components facilitate communication and coordination in robotic systems, particularly for humanoid robots."}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand the fundamental concepts of ROS 2: nodes, topics, services, and actions."}),"\n",(0,t.jsx)(n.li,{children:"Differentiate between topics (publish/subscribe), services (request/reply), and actions (goal/cancel/feedback/result)."}),"\n",(0,t.jsxs)(n.li,{children:["Implement basic ROS 2 nodes in Python using ",(0,t.jsx)(n.code,{children:"rclpy"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Design communication patterns between ROS 2 nodes for humanoid control."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"31-nodes-topics-services-and-actions",children:"3.1 Nodes, Topics, Services, and Actions"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 is a middleware framework that enables communication between different processes (nodes) in a robotic system. It provides four primary communication mechanisms:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nodes"}),": Individual processes that perform computation. Nodes are the basic unit of computation in ROS 2."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topics"}),": A publish/subscribe communication pattern for streaming data (e.g., sensor data, actuator commands)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": A request/reply communication pattern for single requests and responses (e.g., changing a robot's mode)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": A goal-oriented communication pattern for long-running tasks with feedback (e.g., navigating to a location)."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Example of a simple ROS 2 publisher node (non-interactive for now)\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello World: %d' % self.i\n        self.publisher_.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var t=i(6540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);