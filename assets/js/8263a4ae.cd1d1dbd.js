"use strict";(self.webpackChunkphysical_ai_textbook=self.webpackChunkphysical_ai_textbook||[]).push([[761],{8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>a});var t=i(6540);const o={},r=t.createContext(o);function s(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(r.Provider,{value:e},n.children)}},8633:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>_,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var t=i(4848),o=i(8453);const r={id:"chapter9",sidebar_position:4,title:"Isaac Sim Integration \u2013 Physics, Rendering & Sensor Simulation"},s="Chapter 9: Isaac Sim Integration \u2013 Physics, Rendering & Sensor Simulation",a={id:"module2/chapter9",title:"Isaac Sim Integration \u2013 Physics, Rendering & Sensor Simulation",description:"Learning Objectives",source:"@site/docs/module2/chapter9.mdx",sourceDirName:"module2",slug:"/module2/chapter9",permalink:"/docs/module2/chapter9",draft:!1,unlisted:!1,editUrl:"https://github.com/your-github-username/physical-ai-textbook/tree/main/docs/module2/chapter9.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"chapter9",sidebar_position:4,title:"Isaac Sim Integration \u2013 Physics, Rendering & Sensor Simulation"},sidebar:"tutorialSidebar",previous:{title:"Building High-Fidelity Environments & Sensor Simulation",permalink:"/docs/module2/chapter8"},next:{title:"Isaac ROS \u2013 Hardware-Accelerated Perception & Navigation",permalink:"/docs/module3/chapter10"}},l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"9.1 Introduction to Isaac Sim Integration",id:"91-introduction-to-isaac-sim-integration",level:2},{value:"9.1.1 Isaac Sim Architecture",id:"911-isaac-sim-architecture",level:3},{value:"9.1.2 Integration Benefits for Humanoid Robotics",id:"912-integration-benefits-for-humanoid-robotics",level:3},{value:"9.2 Isaac Sim Setup and Configuration",id:"92-isaac-sim-setup-and-configuration",level:2},{value:"9.2.1 Installation and Prerequisites",id:"921-installation-and-prerequisites",level:3},{value:"9.2.2 Basic Configuration for Humanoid Robots",id:"922-basic-configuration-for-humanoid-robots",level:3},{value:"9.2.3 Humanoid-Specific Physics Configuration",id:"923-humanoid-specific-physics-configuration",level:3},{value:"9.3 Physics Simulation for Humanoid Locomotion",id:"93-physics-simulation-for-humanoid-locomotion",level:2},{value:"9.3.1 Dynamics Modeling for Bipedal Locomotion",id:"931-dynamics-modeling-for-bipedal-locomotion",level:3},{value:"9.3.2 Contact Modeling for Humanoid Feet",id:"932-contact-modeling-for-humanoid-feet",level:3},{value:"9.4 Rendering and Visualization",id:"94-rendering-and-visualization",level:2},{value:"9.4.1 High-Fidelity Rendering Setup",id:"941-high-fidelity-rendering-setup",level:3},{value:"9.4.2 Material and Texture Simulation",id:"942-material-and-texture-simulation",level:3},{value:"9.5 Sensor Simulation and Integration",id:"95-sensor-simulation-and-integration",level:2},{value:"9.5.1 IMU Simulation",id:"951-imu-simulation",level:3},{value:"9.5.2 Force/Torque Sensor Simulation",id:"952-forcetorque-sensor-simulation",level:3},{value:"9.6 Integration with ROS 2",id:"96-integration-with-ros-2",level:2},{value:"9.6.1 Isaac Sim ROS Bridge Configuration",id:"961-isaac-sim-ros-bridge-configuration",level:3}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"chapter-9-isaac-sim-integration--physics-rendering--sensor-simulation",children:"Chapter 9: Isaac Sim Integration \u2013 Physics, Rendering & Sensor Simulation"}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Integrate Isaac Sim with ROS 2 for humanoid robot simulation"}),"\n",(0,t.jsx)(e.li,{children:"Configure physics parameters for realistic humanoid dynamics"}),"\n",(0,t.jsx)(e.li,{children:"Set up high-fidelity rendering for vision-based tasks"}),"\n",(0,t.jsx)(e.li,{children:"Implement accurate sensor simulation for humanoid robots"}),"\n",(0,t.jsx)(e.li,{children:"Validate simulation results against real-world data"}),"\n",(0,t.jsx)(e.li,{children:"Optimize simulation performance for training and deployment"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"91-introduction-to-isaac-sim-integration",children:"9.1 Introduction to Isaac Sim Integration"}),"\n",(0,t.jsx)(e.p,{children:"Isaac Sim provides a comprehensive simulation environment that bridges the gap between virtual development and real-world robotics. For humanoid robots, Isaac Sim offers several key advantages:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Photorealistic Rendering"}),": High-fidelity visual simulation for training vision systems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physically Accurate Simulation"}),": Advanced physics engine for realistic robot-environment interactions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Hardware Acceleration"}),": GPU-accelerated simulation for large-scale training"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"AI Framework Integration"}),": Direct integration with NVIDIA's AI tools"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS 2 Bridge"}),": Seamless integration with ROS 2 for real-world deployment"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"911-isaac-sim-architecture",children:"9.1.1 Isaac Sim Architecture"}),"\n",(0,t.jsx)(e.p,{children:"The Isaac Sim architecture consists of several key components:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"USD (Universal Scene Description)"}),": Core data model for representing scenes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"PhysX Engine"}),": NVIDIA's physics simulation engine"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Omniverse Kit"}),": Application framework for 3D simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Isaac Extensions"}),": Robotics-specific extensions for sensing and control"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS 2 Bridge"}),": Two-way communication with ROS 2 ecosystem"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"912-integration-benefits-for-humanoid-robotics",children:"9.1.2 Integration Benefits for Humanoid Robotics"}),"\n",(0,t.jsx)(e.p,{children:"Isaac Sim integration provides specific benefits for humanoid robot development:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Complex Dynamics"}),": Accurate simulation of multi-contact scenarios during walking"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"High-DOF Control"}),": Support for robots with many degrees of freedom"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor Fusion"}),": Integration of multiple sensor modalities"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real-time Performance"}),": High-fidelity simulation at interactive rates"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Scalability"}),": Support for parallel simulation environments"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"92-isaac-sim-setup-and-configuration",children:"9.2 Isaac Sim Setup and Configuration"}),"\n",(0,t.jsx)(e.h3,{id:"921-installation-and-prerequisites",children:"9.2.1 Installation and Prerequisites"}),"\n",(0,t.jsx)(e.p,{children:"To properly set up Isaac Sim for humanoid robotics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Prerequisites\n# - NVIDIA GPU with CUDA support (RTX series recommended)\n# - Compatible NVIDIA drivers\n# - Ubuntu 20.04 or 22.04\n\n# Download Isaac Sim from NVIDIA Developer website\nwget https://developer.download.nvidia.com/isaac/isaac_sim.isac\n\n# Extract and install\ntar -xf isaac_sim.tar.bz2\ncd isaac_sim\n./install_dependencies.sh\n./run_headless.py --skip-pull\n"})}),"\n",(0,t.jsx)(e.h3,{id:"922-basic-configuration-for-humanoid-robots",children:"9.2.2 Basic Configuration for Humanoid Robots"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# Isaac Sim configuration for humanoid simulation\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nfrom omni.isaac.core.robots import Robot\nfrom omni.isaac.core.articulations import Articulation\n\nclass IsaacSimHumanoidConfig:\n    """Configuration class for Isaac Sim humanoid simulation"""\n\n    def __init__(self):\n        # Simulation parameters\n        self.simulation_params = {\n            "physics_dt": 1.0/60.0,      # Physics timestep (s)\n            "rendering_dt": 1.0/60.0,    # Rendering timestep (s)\n            "stage_units_in_meters": 1.0, # World scale factor\n            "enable_scene_query_support": True,  # Enable raycasting\n            "default_physics_material": {\n                "static_friction": 0.5,\n                "dynamic_friction": 0.5,\n                "restitution": 0.1\n            }\n        }\n\n        # Physics settings for humanoid locomotion\n        self.physics_settings = {\n            "solver_type": "TGS",        # TGS or PGS\n            "solver_position_iteration_count": 8,\n            "solver_velocity_iteration_count": 4,\n            "sleep_threshold": 0.005,    # Velocity threshold for sleeping\n            "stabilization_threshold": 0.01,  # Position stabilization threshold\n            "enable_ccd": False,         # Continuous collision detection\n            "ccd_threshold": 1e-5,       # CCD activation threshold\n            "max_depenetration_velocity": 100.0  # Max penetration recovery velocity\n        }\n\n        # Rendering settings\n        self.rendering_settings = {\n            "resolution": [1280, 720],   # Render resolution\n            "enable_hydra_texture_streaming": True,\n            "lighting_quality": "high",\n            "shadows": "enabled",\n            "reflections": "realistic",\n            "post_processing": "enabled"\n        }\n\n    def setup_simulation_environment(self):\n        """Set up the simulation environment with humanoid-specific settings"""\n        # Get the timeline interface\n        timeline = omni.timeline.get_timeline_interface()\n\n        # Configure physics settings\n        physics_settings = carb.settings.get_settings()\n        physics_settings.set("/physics/solverType", self.physics_settings["solver_type"])\n        physics_settings.set("/physics/solverPositionIterationCount",\n                            self.physics_settings["solver_position_iteration_count"])\n        physics_settings.set("/physics/solverVelocityIterationCount",\n                            self.physics_settings["solver_velocity_iteration_count"])\n        physics_settings.set("/physics/sleepThreshold",\n                            self.physics_settings["sleep_threshold"])\n        physics_settings.set("/physics/stabilizationThreshold",\n                            self.physics_settings["stabilization_threshold"])\n        physics_settings.set("/physics/enableCCD",\n                            self.physics_settings["enable_ccd"])\n        physics_settings.set("/physics/ccdThreshold",\n                            self.physics_settings["ccd_threshold"])\n        physics_settings.set("/physics/maxDepenetrationVelocity",\n                            self.physics_settings["max_depenetration_velocity"])\n\n        print("Isaac Sim environment configured for humanoid simulation")\n\n    def create_humanoid_world(self):\n        """Create a world configured for humanoid robot simulation"""\n        # Initialize the world with appropriate settings\n        world = World(\n            stage_units_in_meters=self.simulation_params["stage_units_in_meters"],\n            physics_dt=self.simulation_params["physics_dt"],\n            rendering_dt=self.simulation_params["rendering_dt"],\n            sim_params=self.simulation_params\n        )\n\n        # Enable scene query support for humanoid-specific operations\n        if self.simulation_params["enable_scene_query_support"]:\n            world.enable_scene_query_support()\n\n        return world\n'})}),"\n",(0,t.jsx)(e.h3,{id:"923-humanoid-specific-physics-configuration",children:"9.2.3 Humanoid-Specific Physics Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# Advanced physics configuration for humanoid dynamics\nhumanoid_physics_config = {\n    "balance_stabilization": {\n        "com_stabilization": {\n            "linear_damping": 0.1,\n            "angular_damping": 0.2,\n            "stabilization_factor": 0.01\n        },\n        "joint_stabilization": {\n            "position_sleep_threshold": 0.001,\n            "velocity_sleep_threshold": 0.01,\n            "max_linear_velocity": 10.0,\n            "max_angular_velocity": 50.0\n        }\n    },\n    "contact_modeling": {\n        "contact_offsets": {\n            "contact_offset": 0.005,      # Contact offset for collision detection\n            "rest_offset": 0.0005,        # Rest offset for contact maintenance\n            "contact_surface_layer": 0.002  # Surface layer thickness\n        },\n        "friction_model": {\n            "friction_coefficient": 0.7,    # Default friction coefficient\n            "friction_combine_mode": "average",  # How to combine friction coefficients\n            "restitution_combine_mode": "average"  # How to combine restitution coefficients\n        },\n        "contact_solver": {\n            "solver_type": "tgs",           # TGS solver for stability\n            "position_iterations": 8,       # Position solver iterations\n            "velocity_iterations": 4,       # Velocity solver iterations\n            "projection_iterations": 4,     # Projection solver iterations\n            "sor": 1.3,                    # Successive Over-Relaxation parameter\n            "max_error_reduction": 0.1      # Max error reduction per iteration\n        }\n    },\n    "actuator_modeling": {\n        "pd_control": {\n            "position_gain": 100.0,         # P gain for position control\n            "velocity_gain": 10.0,          # D gain for velocity control\n            "max_force": 1000.0,            # Maximum actuator force\n            "max_velocity": 10.0            # Maximum actuator velocity\n        },\n        "motor_characteristics": {\n            "torque_constant": 0.1,         # Torque constant (Nm/A)\n            "gear_ratio": 100.0,            # Gear ratio\n            "max_current": 10.0,            # Maximum motor current (A)\n            "internal_friction": 0.01,      # Internal friction coefficient\n            "backlash": 0.001               # Gear backlash (rad)\n        }\n    }\n}\n\n# Physics material properties for humanoid components\nhumanoid_material_properties = {\n    "feet_material": {\n        "static_friction": 0.8,      # High friction for stable footing\n        "dynamic_friction": 0.7,     # Dynamic friction slightly lower\n        "restitution": 0.1,          # Low restitution for stable contact\n        "compliance": 0.001,         # Slight compliance for realistic contact\n        "damping": 0.1               # Contact damping\n    },\n    "hand_material": {\n        "static_friction": 0.6,      # Moderate friction for grasping\n        "dynamic_friction": 0.5,\n        "restitution": 0.2,\n        "compliance": 0.002,\n        "damping": 0.05\n    },\n    "body_material": {\n        "static_friction": 0.3,      # Lower friction for sliding protection\n        "dynamic_friction": 0.3,\n        "restitution": 0.1,\n        "compliance": 0.001,\n        "damping": 0.01\n    },\n    "environment_material": {\n        "static_friction": 0.5,      # Generic environment friction\n        "dynamic_friction": 0.4,\n        "restitution": 0.1,\n        "compliance": 0.0001,\n        "damping": 0.01\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"93-physics-simulation-for-humanoid-locomotion",children:"9.3 Physics Simulation for Humanoid Locomotion"}),"\n",(0,t.jsx)(e.h3,{id:"931-dynamics-modeling-for-bipedal-locomotion",children:"9.3.1 Dynamics Modeling for Bipedal Locomotion"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid locomotion requires accurate modeling of complex multi-body dynamics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# Dynamics modeling for humanoid walking\nclass HumanoidDynamicsModel:\n    """Model for humanoid dynamics in Isaac Sim"""\n\n    def __init__(self, robot_mass=80.0, gravity=9.81):\n        self.mass = robot_mass\n        self.gravity = gravity\n\n        # Inertia properties for humanoid links\n        self.link_inertias = {\n            "pelvis": [1.0, 1.0, 1.0, 0.0, 0.0, 0.0],  # [ixx, iyy, izz, ixy, ixz, iyz]\n            "torso": [2.0, 2.0, 0.5, 0.0, 0.0, 0.0],\n            "head": [0.1, 0.1, 0.1, 0.0, 0.0, 0.0],\n            "upper_arm": [0.1, 0.1, 0.05, 0.0, 0.0, 0.0],\n            "lower_arm": [0.05, 0.05, 0.02, 0.0, 0.0, 0.0],\n            "hand": [0.02, 0.02, 0.02, 0.0, 0.0, 0.0],\n            "thigh": [0.5, 0.5, 0.1, 0.0, 0.0, 0.0],\n            "shin": [0.2, 0.2, 0.05, 0.0, 0.0, 0.0],\n            "foot": [0.1, 0.1, 0.05, 0.0, 0.0, 0.0]\n        }\n\n    def compute_inverse_dynamics(self, joint_positions, joint_velocities, joint_accelerations):\n        """Compute inverse dynamics to find required joint torques"""\n        # This is a simplified representation\n        # In practice, this would use more sophisticated algorithms like RNEA (Recursive Newton-Euler Algorithm)\n\n        # Calculate Coriolis and centrifugal effects\n        coriolis_terms = self._compute_coriolis_forces(joint_positions, joint_velocities)\n\n        # Calculate gravitational effects\n        gravity_terms = self._compute_gravity_forces(joint_positions)\n\n        # Calculate inertial effects\n        inertia_terms = self._compute_inertial_forces(joint_accelerations)\n\n        # Total required torques\n        required_torques = inertia_terms + coriolis_terms + gravity_terms\n\n        return required_torques\n\n    def _compute_coriolis_forces(self, q, q_dot):\n        """Compute Coriolis and centrifugal forces"""\n        # Simplified implementation - in reality this would involve the Christoffel symbols\n        # and would be computed based on the robot\'s specific kinematic structure\n        return np.zeros_like(q_dot)\n\n    def _compute_gravity_forces(self, q):\n        """Compute gravity-induced forces"""\n        # Simplified implementation - depends on robot configuration\n        return np.zeros_like(q)\n\n    def _compute_inertial_forces(self, q_ddot):\n        """Compute inertial forces"""\n        # Simplified implementation - would involve full mass matrix calculation\n        return np.zeros_like(q_ddot)\n\n    def compute_balance_metrics(self, com_pos, com_vel, zmp_pos):\n        """Compute balance metrics for humanoid locomotion"""\n        # Zero-Moment Point (ZMP) calculation\n        zmp_error = np.linalg.norm(zmp_pos[:2] - com_pos[:2])\n\n        # Angular momentum around CoM\n        angular_momentum = self._compute_angular_momentum(com_vel)\n\n        # Stability margin\n        support_polygon = self._compute_support_polygon()\n        stability_margin = self._compute_distance_to_support_boundary(com_pos[:2], support_polygon)\n\n        return {\n            "zmp_error": zmp_error,\n            "angular_momentum": angular_momentum,\n            "stability_margin": stability_margin\n        }\n\n    def _compute_angular_momentum(self, com_vel):\n        """Compute angular momentum around center of mass"""\n        # Simplified calculation\n        return np.cross(com_vel[:2], self.mass * com_vel[2])\n\n    def _compute_support_polygon(self):\n        """Compute the support polygon based on contact points"""\n        # Would be computed based on current foot contact points\n        return np.array([[0.1, 0.05], [0.1, -0.05], [-0.1, -0.05], [-0.1, 0.05]])  # Example\n\n    def _compute_distance_to_support_boundary(self, point, polygon):\n        """Compute distance from point to support polygon boundary"""\n        # Would use computational geometry to find distance\n        return 0.0  # Placeholder\n'})}),"\n",(0,t.jsx)(e.h3,{id:"932-contact-modeling-for-humanoid-feet",children:"9.3.2 Contact Modeling for Humanoid Feet"}),"\n",(0,t.jsx)(e.p,{children:"Accurate contact modeling is critical for stable humanoid locomotion:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# Advanced contact modeling for humanoid feet\nfoot_contact_model_config = {\n    "contact_geometry": {\n        "shape": "rectangular",           # Rectangular contact patch\n        "dimensions": [0.15, 0.08, 0.01], # Length, width, thickness (m)\n        "contact_points": 4,              # Number of contact points\n        "pressure_distribution": "elliptical", # Pressure distribution model\n        "contact_patch_offset": [0.0, 0.0, -0.01]  # Offset from ankle\n    },\n    "contact_dynamics": {\n        "friction_model": "cone",          # Friction cone model\n        "stiction_model": True,            # Include stiction effects\n        "micro_slip": 0.001,              # Allowable micro-slip (m)\n        "contact_damping": 1000.0,         # Contact damping coefficient\n        "elastic_modulus": 1e6,           # Elastic modulus for soft contacts\n        "poisson_ratio": 0.3              # Poisson\'s ratio for material\n    },\n    "contact_solver": {\n        "solver_iterations": 50,           # Solver iterations for contacts\n        "solver_tolerance": 1e-6,         # Convergence tolerance\n        "contact_offset": 0.001,          # Penetration allowance\n        "rest_offset": 0.0,               # Resting contact offset\n        "baumgarte_stabilization": 0.1    # Baumgarte stabilization parameter\n    },\n    "balance_considerations": {\n        "center_of_pressure": True,        # Enable CoP computation\n        "zero_moment_point": True,         # Enable ZMP computation\n        "capture_point": True,             # Enable capture point computation\n        "ankle_strategy_enabled": True,    # Enable ankle strategy for balance\n        "hip_strategy_enabled": True,      # Enable hip strategy for balance\n        "stepping_strategy": True          # Enable stepping for balance recovery\n    }\n}\n\n# Implementation of foot contact model\nclass FootContactModel:\n    """Model for humanoid foot contacts in Isaac Sim"""\n\n    def __init__(self, config):\n        self.config = config\n        self.contact_points = self._generate_contact_points()\n        self.pressure_distribution = self._generate_pressure_distribution()\n\n    def _generate_contact_points(self):\n        """Generate contact points based on foot geometry"""\n        # Create contact points in a rectangular pattern\n        length = self.config["contact_geometry"]["dimensions"][0]\n        width = self.config["contact_geometry"]["dimensions"][1]\n\n        points = []\n        # Generate grid of contact points\n        for i in range(2):  # 2 points along length\n            for j in range(2):  # 2 points along width\n                x = (i - 0.5) * length\n                y = (j - 0.5) * width\n                points.append([x, y, 0.0])\n\n        return np.array(points)\n\n    def _generate_pressure_distribution(self):\n        """Generate pressure distribution across foot"""\n        # Elliptical pressure distribution model\n        points = self.contact_points\n        pressures = np.zeros(len(points))\n\n        # Calculate distances from center\n        center = np.array([0.0, 0.0, 0.0])\n        for i, point in enumerate(points):\n            dist_from_center = np.linalg.norm(point[:2] - center[:2])\n            # Elliptical distribution (simplified)\n            pressure = np.exp(-dist_from_center / 0.05)  # Decay factor\n            pressures[i] = pressure\n\n        return pressures / np.sum(pressures)  # Normalize\n\n    def compute_contact_forces(self, foot_pose, ground_normal, ground_position):\n        """Compute contact forces for foot-ground interaction"""\n        # Transform contact points to world coordinates\n        world_points = self._transform_points_to_world(foot_pose, self.contact_points)\n\n        # Determine which points are in contact\n        contact_mask = self._check_ground_contacts(world_points, ground_position)\n\n        # Compute forces at contact points\n        forces = np.zeros((len(world_points), 3))\n\n        for i, point in enumerate(world_points):\n            if contact_mask[i]:\n                # Compute normal force based on penetration depth\n                penetration = max(0, ground_position[2] - point[2])\n\n                # Spring-damper model\n                normal_force = self.config["contact_dynamics"]["elastic_modulus"] * penetration\n                damping_force = self.config["contact_dynamics"]["contact_damping"] * (point[2] - ground_position[2])\n\n                # Total normal force\n                total_normal_force = max(0, normal_force + damping_force)\n\n                # Apply friction cone constraint\n                tangential_force = self._apply_friction_cone(total_normal_force)\n\n                # Set contact force\n                forces[i] = tangential_force + total_normal_force * ground_normal\n\n        return forces\n\n    def _transform_points_to_world(self, pose, points):\n        """Transform points from foot frame to world frame"""\n        # Apply pose transformation to points\n        # pose should be in [position, quaternion] format\n        pos, quat = pose[:3], pose[3:]\n\n        # Convert quaternion to rotation matrix\n        rot_matrix = self._quaternion_to_rotation_matrix(quat)\n\n        # Transform points\n        world_points = []\n        for point in points:\n            rotated_point = np.dot(rot_matrix, point)\n            translated_point = rotated_point + pos\n            world_points.append(translated_point)\n\n        return np.array(world_points)\n\n    def _check_ground_contacts(self, world_points, ground_position):\n        """Check which points are in contact with ground"""\n        # Simple ground contact check\n        tolerance = 0.001  # 1mm tolerance\n        contacts = []\n\n        for point in world_points:\n            # Check if point is close to ground\n            distance_to_ground = abs(point[2] - ground_position[2])\n            contacts.append(distance_to_ground < tolerance)\n\n        return contacts\n\n    def _apply_friction_cone_constraint(self, normal_force):\n        """Apply friction cone constraint to tangential forces"""\n        # Friction coefficient\n        mu = self.config["contact_dynamics"]["friction_coefficient"]\n\n        # Maximum tangential force\n        max_tangential_force = mu * normal_force\n\n        # For simplicity, return zero tangential force\n        # In a real implementation, this would consider actual tangential forces\n        return np.array([0.0, 0.0, 0.0])\n\n    def update_contact_properties(self, terrain_type):\n        """Update contact properties based on terrain type"""\n        terrain_properties = {\n            "flat_ground": {\n                "friction_coefficient": 0.7,\n                "elastic_modulus": 1e6,\n                "damping_coefficient": 1000\n            },\n            "carpet": {\n                "friction_coefficient": 0.8,\n                "elastic_modulus": 5e5,\n                "damping_coefficient": 2000\n            },\n            "tile": {\n                "friction_coefficient": 0.6,\n                "elastic_modulus": 2e6,\n                "damping_coefficient": 500\n            },\n            "grass": {\n                "friction_coefficient": 0.5,\n                "elastic_modulus": 1e5,\n                "damping_coefficient": 3000\n            }\n        }\n\n        if terrain_type in terrain_properties:\n            props = terrain_properties[terrain_type]\n            self.config["contact_dynamics"]["friction_coefficient"] = props["friction_coefficient"]\n            self.config["contact_dynamics"]["elastic_modulus"] = props["elastic_modulus"]\n            self.config["contact_dynamics"]["damping_coefficient"] = props["damping_coefficient"]\n'})}),"\n",(0,t.jsx)(e.h2,{id:"94-rendering-and-visualization",children:"9.4 Rendering and Visualization"}),"\n",(0,t.jsx)(e.h3,{id:"941-high-fidelity-rendering-setup",children:"9.4.1 High-Fidelity Rendering Setup"}),"\n",(0,t.jsx)(e.p,{children:"For humanoid robotics, high-fidelity rendering is essential for training vision-based systems:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# High-fidelity rendering configuration for humanoid simulation\nrendering_config = {\n    "ray_tracing": {\n        "enable_ray_tracing": True,\n        "max_bounces": 8,                    # Maximum ray bounces\n        "light_sampling": "multiple_importance",  # Light sampling method\n        "environment_sampling": True,         # Sample environment lights\n        "material_sampling": True            # Sample material properties\n    },\n    "global_illumination": {\n        "enable_living_color": True,         # Global illumination\n        "light_linking": True,               # Proper light linking\n        "volume_scattering": True,           # Volume scattering effects\n        "subsurface_scattering": True        # Subsurface scattering\n    },\n    "camera_simulation": {\n        "rgb_camera": {\n            "resolution": [1280, 720],       # HD resolution\n            "fov": 60,                       # Field of view in degrees\n            "near_clip": 0.1,                # Near clipping plane\n            "far_clip": 100.0,               # Far clipping plane\n            "sensor_tilt": 0.0,              # Sensor tilt angle\n            "mounting_height": 1.5           # Camera mounting height\n        },\n        "depth_camera": {\n            "resolution": [640, 480],        # Depth map resolution\n            "fov": 60,                       # Field of view\n            "min_range": 0.1,                # Minimum depth range\n            "max_range": 10.0,               # Maximum depth range\n            "depth_unit": "meters",          # Depth unit\n            "depth_format": "float32"        # Depth data format\n        },\n        "stereo_camera": {\n            "baseline": 0.12,                # Stereo baseline (m)\n            "focal_length": 0.008,           # Focal length (m)\n            "disparity_range": (-64, 64),    # Disparity range\n            "algorithm": "sgbm"              # Stereo algorithm\n        }\n    },\n    "sensor_noise_simulation": {\n        "camera_noise": {\n            "gaussian_noise_std": 0.01,      # Standard deviation of Gaussian noise\n            "poisson_noise_factor": 0.001,   # Poisson noise scaling factor\n            "dropout_probability": 0.001,    # Pixel dropout probability\n            "temporal_noise": True           # Enable temporal noise\n        },\n        "distortion": {\n            "radial_distortion": True,       # Enable radial distortion\n            "tangential_distortion": True,   # Enable tangential distortion\n            "thin_prism_distortion": False,  # Thin prism distortion\n            "k1": -0.1,                     # Radial distortion coefficient\n            "k2": 0.02,                     # Radial distortion coefficient\n            "k3": -0.001,                   # Radial distortion coefficient\n            "p1": 0.001,                    # Tangential distortion coefficient\n            "p2": -0.001                    # Tangential distortion coefficient\n        }\n    },\n    "performance_settings": {\n        "render_resolution_scale": 0.8,      # Scale rendering resolution\n        "lod_bias": 0.5,                    # Level of detail bias\n        "texture_resolution": "high",       # Texture resolution level\n        "shadow_quality": "high",           # Shadow quality level\n        "reflection_quality": "medium",     # Reflection quality level\n        "post_processing": "full"           # Post-processing level\n    }\n}\n\n# Implementation of rendering manager\nclass RenderingManager:\n    """Manage high-fidelity rendering for humanoid simulation"""\n\n    def __init__(self, config):\n        self.config = config\n        self.cameras = {}\n        self.lights = {}\n        self.materials = {}\n\n    def setup_cameras(self, robot_prim_path):\n        """Set up cameras for humanoid robot"""\n        # Create RGB camera\n        rgb_camera_path = f"{robot_prim_path}/head/rgb_camera"\n        self.cameras["rgb"] = self._create_rgb_camera(rgb_camera_path)\n\n        # Create depth camera\n        depth_camera_path = f"{robot_prim_path}/head/depth_camera"\n        self.cameras["depth"] = self._create_depth_camera(depth_camera_path)\n\n        # Create fisheye camera for wide FOV\n        fisheye_camera_path = f"{robot_prim_path}/head/fisheye_camera"\n        self.cameras["fisheye"] = self._create_fisheye_camera(fisheye_camera_path)\n\n    def _create_rgb_camera(self, camera_path):\n        """Create RGB camera sensor"""\n        from omni.isaac.sensor import Camera\n\n        camera = Camera(\n            prim_path=camera_path,\n            frequency=self.config["camera_simulation"]["rgb_camera"]["fov"],\n            resolution=self.config["camera_simulation"]["rgb_camera"]["resolution"]\n        )\n\n        # Apply noise parameters\n        if self.config["sensor_noise_simulation"]["camera_noise"]["gaussian_noise_std"] > 0:\n            camera.add_noise_params(\n                gaussian_std=self.config["sensor_noise_simulation"]["camera_noise"]["gaussian_noise_std"],\n                poisson_multiplier=self.config["sensor_noise_simulation"]["camera_noise"]["poisson_noise_factor"]\n            )\n\n        # Apply distortion parameters\n        if self.config["sensor_noise_simulation"]["distortion"]["radial_distortion"]:\n            camera.set_distortion_params(\n                k1=self.config["sensor_noise_simulation"]["distortion"]["k1"],\n                k2=self.config["sensor_noise_simulation"]["distortion"]["k2"],\n                k3=self.config["sensor_noise_simulation"]["distortion"]["k3"],\n                p1=self.config["sensor_noise_simulation"]["distortion"]["p1"],\n                p2=self.config["sensor_noise_simulation"]["distortion"]["p2"]\n            )\n\n        return camera\n\n    def _create_depth_camera(self, camera_path):\n        """Create depth camera sensor"""\n        from omni.isaac.sensor import Camera\n\n        depth_camera = Camera(\n            prim_path=camera_path,\n            frequency=self.config["camera_simulation"]["depth_camera"]["fov"],\n            resolution=self.config["camera_simulation"]["depth_camera"]["resolution"]\n        )\n\n        # Configure depth-specific parameters\n        depth_camera.set_depth_range(\n            min_range=self.config["camera_simulation"]["depth_camera"]["min_range"],\n            max_range=self.config["camera_simulation"]["depth_camera"]["max_range"]\n        )\n\n        return depth_camera\n\n    def _create_fisheye_camera(self, camera_path):\n        """Create fisheye camera sensor"""\n        from omni.isaac.sensor import Camera\n\n        fisheye_camera = Camera(\n            prim_path=camera_path,\n            frequency=180,  # 180 degree FOV for fisheye\n            resolution=[640, 640]  # Square resolution for fisheye\n        )\n\n        # Apply fisheye distortion model\n        fisheye_camera.set_distortion_params(\n            distortion_model="fisheye_equidistant",\n            distortion_coefficients=[0.1, 0.02, 0.0, 0.0]  # k1, k2, k3, k4\n        )\n\n        return fisheye_camera\n\n    def setup_advanced_lighting(self):\n        """Set up advanced lighting for realistic rendering"""\n        # Create dome light for even illumination\n        self.lights["dome"] = self._create_dome_light()\n\n        # Add directional sun light\n        self.lights["sun"] = self._create_sun_light()\n\n        # Add spot lights for localized illumination\n        self.lights["spot"] = self._create_spot_lights()\n\n    def _create_dome_light(self):\n        """Create dome light for even scene illumination"""\n        from omni.isaac.core.utils.prims import define_prim\n        from pxr import UsdLux\n\n        dome_light_path = "/World/DomeLight"\n        define_prim(dome_light_path, "DomeLight")\n\n        dome_light = UsdLux.DomeLight.Define(self.stage, dome_light_path)\n        dome_light.CreateIntensityAttr(1.0)\n        dome_light.CreateTextureFileAttr("path/to/environment_map.hdr")\n        dome_light.CreateColorAttr((0.9, 0.9, 1.0))  # Slightly blue tint\n\n        return dome_light\n\n    def _create_sun_light(self):\n        """Create directional sun light"""\n        from omni.isaac.core.utils.prims import define_prim\n        from pxr import UsdLux\n\n        sun_light_path = "/World/SunLight"\n        define_prim(sun_light_path, "DistantLight")\n\n        sun_light = UsdLux.DistantLight.Define(self.stage, sun_light_path)\n        sun_light.CreateIntensityAttr(3000.0)\n        sun_light.CreateColorAttr((1.0, 0.98, 0.94))  # Warm sunlight\n        sun_light.AddRotateXYZOp().Set((-45, 30, 0))  # Direction\n\n        return sun_light\n\n    def _create_spot_lights(self):\n        """Create spot lights for localized illumination"""\n        from omni.isaac.core.utils.prims import define_prim\n        from pxr import UsdLux\n\n        spot_lights = []\n        positions = [\n            [2.0, 0.0, 3.0],\n            [-2.0, 0.0, 3.0],\n            [0.0, 2.0, 3.0],\n            [0.0, -2.0, 3.0]\n        ]\n\n        for i, pos in enumerate(positions):\n            spot_light_path = f"/World/SpotLight_{i}"\n            define_prim(spot_light_path, "SpotLight")\n\n            spot_light = UsdLux.SpotLight.Define(self.stage, spot_light_path)\n            spot_light.CreateIntensityAttr(500.0)\n            spot_light.CreateColorAttr((1.0, 1.0, 1.0))\n            spot_light.AddTranslateOp().Set(pos)\n            spot_light.CreateShapingConeAngleAttr(60.0)\n            spot_light.CreateShapingConeSoftnessAttr(0.2)\n\n            spot_lights.append(spot_light)\n\n        return spot_lights\n'})}),"\n",(0,t.jsx)(e.h3,{id:"942-material-and-texture-simulation",children:"9.4.2 Material and Texture Simulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# Material and texture simulation for realistic humanoid rendering\nmaterial_config = {\n    "robot_materials": {\n        "body_shell": {\n            "base_color": [0.7, 0.7, 0.7],      # Metallic gray\n            "metallic": 0.8,                     # Metallic appearance\n            "roughness": 0.2,                    # Smooth surface\n            "specular": 0.5,                     # Specular reflection\n            "opacity": 1.0,                      # Opaque\n            "ior": 1.5,                         # Index of refraction\n            "normal_map_strength": 0.1,          # Normal map detail\n            "displacement_scale": 0.001          # Surface displacement\n        },\n        "joints": {\n            "base_color": [0.3, 0.3, 0.3],      # Dark gray\n            "metallic": 0.9,                     # Highly metallic\n            "roughness": 0.3,                    # Slightly rough\n            "specular": 0.8,\n            "opacity": 1.0,\n            "ior": 1.8\n        },\n        "actuators": {\n            "base_color": [0.2, 0.2, 0.2],      # Black\n            "metallic": 0.1,                     # Non-metallic\n            "roughness": 0.7,                    # Rough surface\n            "specular": 0.2,\n            "opacity": 1.0,\n            "ior": 1.3\n        }\n    },\n    "environment_materials": {\n        "floor": {\n            "base_color": [0.8, 0.8, 0.8],      # Light gray\n            "metallic": 0.0,                     # Non-metallic\n            "roughness": 0.5,                    # Medium roughness\n            "specular": 0.1,\n            "opacity": 1.0,\n            "ior": 1.4,\n            "texture": "assets/textures/floor_tile_01.png"\n        },\n        "walls": {\n            "base_color": [0.9, 0.9, 0.9],      # White\n            "metallic": 0.0,\n            "roughness": 0.6,\n            "specular": 0.1,\n            "opacity": 1.0,\n            "ior": 1.3,\n            "texture": "assets/textures/wall_paint_01.png"\n        },\n        "furniture": {\n            "base_color": [0.6, 0.4, 0.2],      # Wood tone\n            "metallic": 0.0,\n            "roughness": 0.4,\n            "specular": 0.2,\n            "opacity": 1.0,\n            "ior": 1.5,\n            "texture": "assets/textures/wood_grain_01.png"\n        }\n    },\n    "special_effects": {\n        "wet_surfaces": {\n            "roughness_multiplier": 0.3,         # Reduce roughness for wet effect\n            "specular_multiplier": 1.5,          # Increase specular for wet effect\n            "normal_map_strength": 0.5           # Add water ripples\n        },\n        "polished_surfaces": {\n            "roughness_multiplier": 0.1,\n            "metallic_multiplier": 1.2,\n            "specular_multiplier": 2.0\n        }\n    }\n}\n\n# Implementation of material manager\nclass MaterialManager:\n    """Manage materials and textures for realistic rendering"""\n\n    def __init__(self, config):\n        self.config = config\n        self.materials = {}\n        self.textures = {}\n\n    def create_robot_materials(self):\n        """Create materials for humanoid robot"""\n        for part_name, part_config in self.config["robot_materials"].items():\n            material_path = f"/World/Materials/Robot_{part_name.replace(\' \', \'_\')}"\n            self.materials[part_name] = self._create_material(material_path, part_config)\n\n    def create_environment_materials(self):\n        """Create materials for environment"""\n        for surface_name, surface_config in self.config["environment_materials"].items():\n            material_path = f"/World/Materials/Env_{surface_name.replace(\' \', \'_\')}"\n            self.materials[f"env_{surface_name}"] = self._create_material(material_path, surface_config)\n\n    def _create_material(self, path, config):\n        """Create a material with specified properties"""\n        from pxr import UsdShade, Sdf\n\n        # Create material prim\n        stage = omni.usd.get_context().get_stage()\n        material = UsdShade.Material.Define(stage, path)\n\n        # Create USD preview surface shader\n        shader_path = Sdf.Path(f"{path}/Shader")\n        shader = UsdShade.Shader.Define(stage, shader_path)\n        shader.CreateIdAttr("UsdPreviewSurface")\n\n        # Set material properties\n        if "base_color" in config:\n            shader.CreateInput("diffuseColor", Sdf.ValueTypeNames.Color3f).Set(config["base_color"])\n        if "metallic" in config:\n            shader.CreateInput("metallic", Sdf.ValueTypeNames.Float).Set(config["metallic"])\n        if "roughness" in config:\n            shader.CreateInput("roughness", Sdf.ValueTypeNames.Float).Set(config["roughness"])\n        if "specular" in config:\n            shader.CreateInput("specularColor", Sdf.ValueTypeNames.Color3f).Set([config["specular"]] * 3)\n        if "opacity" in config:\n            shader.CreateInput("opacity", Sdf.ValueTypeNames.Float).Set(config["opacity"])\n        if "ior" in config:\n            shader.CreateInput("indexOfRefraction", Sdf.ValueTypeNames.Float).Set(config["ior"])\n\n        # Bind material to surface\n        material.CreateSurfaceOutput().ConnectToSource(shader.ConnectableAPI(), "surface")\n\n        return material\n\n    def apply_material_to_robot(self, robot_prim_path):\n        """Apply materials to robot parts"""\n        # Apply materials to different robot parts based on their function\n        for link_name, material_name in [\n            ("base_link", "body_shell"),\n            ("torso", "body_shell"),\n            ("head", "body_shell"),\n            ("upper_arm", "joints"),\n            ("lower_arm", "body_shell"),\n            ("hand", "actuators"),\n            ("thigh", "joints"),\n            ("shin", "body_shell"),\n            ("foot", "actuators")\n        ]:\n            link_path = f"{robot_prim_path}/{link_name}"\n            if link_path in self.materials:\n                self._assign_material_to_geometry(link_path, self.materials[material_name])\n\n    def _assign_material_to_geometry(self, geometry_path, material):\n        """Assign material to geometry prim"""\n        from pxr import UsdShade\n\n        stage = omni.usd.get_context().get_stage()\n        geom_prim = stage.GetPrimAtPath(geometry_path)\n\n        if geom_prim.IsValid():\n            UsdShade.MaterialBindingAPI(geom_prim).Bind(material)\n        else:\n            print(f"Warning: Geometry prim not found at {geometry_path}")\n'})}),"\n",(0,t.jsx)(e.h2,{id:"95-sensor-simulation-and-integration",children:"9.5 Sensor Simulation and Integration"}),"\n",(0,t.jsx)(e.h3,{id:"951-imu-simulation",children:"9.5.1 IMU Simulation"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots require accurate IMU simulation for balance and locomotion:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# IMU simulation for humanoid balance\nimu_config = {\n    "imu_properties": {\n        "accelerometer": {\n            "range": 16.0,                    # g (Earth gravities)\n            "resolution": 1e-6,               # g per LSB\n            "noise_density": 100.0e-6,        # g/sqrt(Hz)\n            "random_walk": 1.0e-6,            # g/s^2/sqrt(Hz)\n            "bias_instability": 5.0e-6,       # g\n            "turn_on_bias_sigma": 20.0e-6     # g\n        },\n        "gyroscope": {\n            "range": 2000.0,                  # deg/s\n            "resolution": 0.001,              # deg/s per LSB\n            "noise_density": 0.01,             # deg/s/sqrt(Hz)\n            "random_walk": 0.0038,             # deg/s^2/sqrt(Hz)\n            "bias_instability": 10.0,          # deg/hour/sqrt(Hz)\n            "turn_on_bias_sigma": 0.5          # deg/s\n        },\n        "magnetometer": {\n            "range": 1300.0,                  # microTesla\n            "resolution": 0.1,                # microTesla per LSB\n            "noise_density": 100.0,            # nT/sqrt(Hz)\n            "hard_iron_distortion": [0.0, 0.0, 0.0],  # microTesla\n            "soft_iron_matrix": [\n                [1.0, 0.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.0, 1.0]\n            ]\n        }\n    },\n    "sensor_placement": {\n        "primary_imu": {\n            "mounting_link": "torso",          # Mount on torso for body orientation\n            "position_offset": [0.0, 0.0, 0.1],  # 10cm above torso origin\n            "orientation_offset": [0.0, 0.0, 0.0, 1.0]  # Identity quaternion\n        },\n        "secondary_imu": {\n            "mounting_link": "head",           # Mount on head for head orientation\n            "position_offset": [0.0, 0.0, 0.05],  # 5cm above head origin\n            "orientation_offset": [0.0, 0.0, 0.0, 1.0]\n        }\n    },\n    "sampling_parameters": {\n        "accelerometer_rate": 1000,            # Hz\n        "gyroscope_rate": 1000,               # Hz\n        "magnetometer_rate": 100,             # Hz (typically lower)\n        "timestamp_accuracy": 1e-6            # 1 microsecond accuracy\n    }\n}\n\n# Implementation of IMU simulator\nclass IMUSimulator:\n    """Simulate IMU sensors for humanoid robot"""\n\n    def __init__(self, config):\n        self.config = config\n        self.accel_noise_gen = self._initialize_noise_generator("accelerometer")\n        self.gyro_noise_gen = self._initialize_noise_generator("gyroscope")\n        self.mag_noise_gen = self._initialize_noise_generator("magnetometer")\n\n        # Bias drift simulation\n        self.accel_bias_drift = np.zeros(3)\n        self.gyro_bias_drift = np.zeros(3)\n        self.mag_bias_drift = np.zeros(3)\n\n    def _initialize_noise_generator(self, sensor_type):\n        """Initialize noise generator for specified sensor type"""\n        sensor_config = self.config["imu_properties"][sensor_type]\n\n        # Create noise model based on sensor specifications\n        noise_model = {\n            "noise_density": sensor_config["noise_density"],\n            "random_walk": sensor_config["random_walk"],\n            "bias_instability": sensor_config["bias_instability"],\n            "turn_on_bias_sigma": sensor_config["turn_on_bias_sigma"]\n        }\n\n        return noise_model\n\n    def simulate_imu_reading(self, true_state, dt):\n        """\n        Simulate IMU reading based on true state and sensor model\n\n        Args:\n            true_state: Dictionary containing true acceleration, angular velocity, magnetic field\n            dt: Time step since last reading\n\n        Returns:\n            Dictionary containing noisy IMU measurements\n        """\n        # Get true values\n        true_accel = np.array(true_state.get("acceleration", [0.0, 0.0, -9.81]))\n        true_ang_vel = np.array(true_state.get("angular_velocity", [0.0, 0.0, 0.0]))\n        true_mag_field = np.array(true_state.get("magnetic_field", [0.21, 0.0, 0.42]))  # Earth\'s magnetic field\n\n        # Simulate accelerometer\n        accel_measurement = self._simulate_accelerometer(true_accel, dt)\n\n        # Simulate gyroscope\n        gyro_measurement = self._simulate_gyroscope(true_ang_vel, dt)\n\n        # Simulate magnetometer\n        mag_measurement = self._simulate_magnetometer(true_mag_field, dt)\n\n        # Update bias drift\n        self._update_bias_drift(dt)\n\n        return {\n            "acceleration": accel_measurement,\n            "angular_velocity": gyro_measurement,\n            "magnetic_field": mag_measurement,\n            "timestamp": true_state.get("timestamp", 0.0)\n        }\n\n    def _simulate_accelerometer(self, true_accel, dt):\n        """Simulate accelerometer measurement"""\n        # Add noise based on noise density\n        accel_noise_std = self.accel_noise_gen["noise_density"] / np.sqrt(dt)\n        accel_noise = np.random.normal(0, accel_noise_std, size=3)\n\n        # Add bias and bias drift\n        accel_bias = np.random.normal(0, self.accel_noise_gen["turn_on_bias_sigma"], size=3)\n        accel_bias += self.accel_bias_drift\n\n        # Add random walk\n        random_walk = np.random.normal(0, self.accel_noise_gen["random_walk"] * np.sqrt(dt), size=3)\n\n        # Combine all effects\n        measured_accel = true_accel + accel_noise + accel_bias + random_walk\n\n        # Apply range limits\n        max_range = self.config["imu_properties"]["accelerometer"]["range"] * 9.81  # Convert g to m/s\xb2\n        measured_accel = np.clip(measured_accel, -max_range, max_range)\n\n        return measured_accel\n\n    def _simulate_gyroscope(self, true_ang_vel, dt):\n        """Simulate gyroscope measurement"""\n        # Convert deg/s to rad/s for internal calculations\n        true_ang_vel_rad = true_ang_vel * np.pi / 180.0\n\n        # Add noise based on noise density\n        gyro_noise_std = self.gyro_noise_gen["noise_density"] * np.pi / 180.0 / np.sqrt(dt)\n        gyro_noise = np.random.normal(0, gyro_noise_std, size=3)\n\n        # Add bias and bias drift\n        gyro_bias = np.random.normal(0, self.gyro_noise_gen["turn_on_bias_sigma"] * np.pi / 180.0, size=3)\n        gyro_bias += self.gyro_bias_drift\n\n        # Add random walk\n        random_walk = np.random.normal(0, self.gyro_noise_gen["random_walk"] * np.pi / 180.0 * np.sqrt(dt), size=3)\n\n        # Combine all effects\n        measured_ang_vel_rad = true_ang_vel_rad + gyro_noise + gyro_bias + random_walk\n\n        # Convert back to deg/s\n        measured_ang_vel = measured_ang_vel_rad * 180.0 / np.pi\n\n        # Apply range limits\n        max_range = self.config["imu_properties"]["gyroscope"]["range"] * np.pi / 180.0\n        measured_ang_vel = np.clip(measured_ang_vel, -max_range, max_range)\n\n        return measured_ang_vel\n\n    def _simulate_magnetometer(self, true_mag_field, dt):\n        """Simulate magnetometer measurement"""\n        # Add noise based on noise density\n        mag_noise_std = self.mag_noise_gen["noise_density"] * 1e-9  # Convert nT to Tesla\n        mag_noise = np.random.normal(0, mag_noise_std, size=3)\n\n        # Add bias and bias drift\n        mag_bias = np.random.normal(0, self.mag_noise_gen["turn_on_bias_sigma"] * 1e-6, size=3)  # microTesla to Tesla\n        mag_bias += self.mag_bias_drift\n\n        # Combine effects\n        measured_mag_field = true_mag_field + mag_noise + mag_bias\n\n        # Apply range limits\n        max_range = self.config["imu_properties"]["magnetometer"]["range"] * 1e-6  # microTesla to Tesla\n        measured_mag_field = np.clip(measured_mag_field, -max_range, max_range)\n\n        return measured_mag_field\n\n    def _update_bias_drift(self, dt):\n        """Update bias drift using first-order Gauss-Markov process"""\n        # Time constants for bias instability (typical values)\n        tau_accel = 1000.0  # seconds\n        tau_gyro = 1000.0   # seconds\n        tau_mag = 1000.0    # seconds\n\n        # Update bias drift using Ornstein-Uhlenbeck process\n        self.accel_bias_drift = self.accel_bias_drift * np.exp(-dt/tau_accel) + \\\n                               np.random.normal(0, self.accel_noise_gen["bias_instability"] * np.sqrt(dt), size=3)\n\n        self.gyro_bias_drift = self.gyro_bias_drift * np.exp(-dt/tau_gyro) + \\\n                              np.random.normal(0, self.gyro_noise_gen["bias_instability"] * np.pi / 180.0 * np.sqrt(dt), size=3)\n\n        self.mag_bias_drift = self.mag_bias_drift * np.exp(-dt/tau_mag) + \\\n                             np.random.normal(0, self.mag_noise_gen["bias_instability"] * 1e-6 * np.sqrt(dt), size=3)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"952-forcetorque-sensor-simulation",children:"9.5.2 Force/Torque Sensor Simulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# Force/Torque sensor simulation for humanoid manipulation\nft_sensor_config = {\n    "wrench_sensors": {\n        "left_foot": {\n            "sensor_type": "6dof_force_torque",\n            "measurement_range": {\n                "force": [2000.0, 2000.0, 2000.0],  # [Fx, Fy, Fz] in Newtons\n                "torque": [200.0, 200.0, 200.0]     # [Tx, Ty, Tz] in Nm\n            },\n            "resolution": {\n                "force": [0.1, 0.1, 0.1],          # Newtons per LSB\n                "torque": [0.01, 0.01, 0.01]       # Nm per LSB\n            },\n            "noise": {\n                "force_std": [1.0, 1.0, 2.0],       # Newtons\n                "torque_std": [0.1, 0.1, 0.2]       # Nm\n            },\n            "bandwidth": 1000,                       # Hz\n            "temperature_drift": {\n                "force_ppm_per_celsius": 50,         # ppm/\xb0C\n                "torque_ppm_per_celsius": 100        # ppm/\xb0C\n            }\n        },\n        "right_foot": {\n            "sensor_type": "6dof_force_torque",\n            "measurement_range": {\n                "force": [2000.0, 2000.0, 2000.0],\n                "torque": [200.0, 200.0, 200.0]\n            },\n            "resolution": {\n                "force": [0.1, 0.1, 0.1],\n                "torque": [0.01, 0.01, 0.01]\n            },\n            "noise": {\n                "force_std": [1.0, 1.0, 2.0],\n                "torque_std": [0.1, 0.1, 0.2]\n            },\n            "bandwidth": 1000,\n            "temperature_drift": {\n                "force_ppm_per_celsius": 50,\n                "torque_ppm_per_celsius": 100\n            }\n        },\n        "left_hand": {\n            "sensor_type": "6dof_force_torque",\n            "measurement_range": {\n                "force": [500.0, 500.0, 500.0],\n                "torque": [50.0, 50.0, 50.0]\n            },\n            "resolution": {\n                "force": [0.05, 0.05, 0.05],\n                "torque": [0.005, 0.005, 0.005]\n            },\n            "noise": {\n                "force_std": [0.5, 0.5, 1.0],\n                "torque_std": [0.05, 0.05, 0.1]\n            },\n            "bandwidth": 1000,\n            "temperature_drift": {\n                "force_ppm_per_celsius": 100,\n                "torque_ppm_per_celsius": 200\n            }\n        },\n        "right_hand": {\n            "sensor_type": "6dof_force_torque",\n            "measurement_range": {\n                "force": [500.0, 500.0, 500.0],\n                "torque": [50.0, 50.0, 50.0]\n            },\n            "resolution": {\n                "force": [0.05, 0.05, 0.05],\n                "torque": [0.005, 0.005, 0.005]\n            },\n            "noise": {\n                "force_std": [0.5, 0.5, 1.0],\n                "torque_std": [0.05, 0.05, 0.1]\n            },\n            "bandwidth": 1000,\n            "temperature_drift": {\n                "force_ppm_per_celsius": 100,\n                "torque_ppm_per_celsius": 200\n            }\n        }\n    },\n    "contact_sensors": {\n        "fingertip_sensors": {\n            "sensor_count": 6,                      # 3 per hand\n            "detection_threshold": 0.5,             # Newtons\n            "normal_accuracy": 0.01,                # Radians\n            "location_accuracy": 0.001,             # Meters\n            "slip_detection": True,\n            "friction_estimation": True\n        }\n    }\n}\n\n# Implementation of Force/Torque sensor simulator\nclass FTSensorSimulator:\n    """Simulate Force/Torque sensors for humanoid robot"""\n\n    def __init__(self, config):\n        self.config = config\n        self.sensors = {}\n\n        # Initialize all sensors\n        for sensor_name, sensor_config in self.config["wrench_sensors"].items():\n            self.sensors[sensor_name] = self._initialize_sensor(sensor_name, sensor_config)\n\n    def _initialize_sensor(self, name, config):\n        """Initialize a force/torque sensor"""\n        sensor = {\n            "name": name,\n            "config": config,\n            "bias": np.zeros(6),  # [Fx, Fy, Fz, Tx, Ty, Tz]\n            "temperature": 25.0,  # Celsius\n            "last_update": 0.0\n        }\n\n        # Initialize bias with turn-on bias\n        bias_std = np.concatenate([\n            config["noise"]["force_std"],\n            config["noise"]["torque_std"]\n        ])\n        sensor["bias"] = np.random.normal(0, bias_std)\n\n        return sensor\n\n    def simulate_sensor_reading(self, sensor_name, true_wrench, dt, temperature=None):\n        """\n        Simulate force/torque sensor reading\n\n        Args:\n            sensor_name: Name of the sensor\n            true_wrench: True wrench vector [Fx, Fy, Fz, Tx, Ty, Tz]\n            dt: Time step since last reading\n            temperature: Current temperature (optional)\n\n        Returns:\n            Noisy sensor reading\n        """\n        if sensor_name not in self.sensors:\n            raise ValueError(f"Sensor {sensor_name} not found")\n\n        sensor = self.sensors[sensor_name]\n        config = sensor["config"]\n\n        # Convert to numpy array\n        true_wrench = np.array(true_wrench)\n\n        # Add measurement noise\n        noise_std = np.concatenate([\n            config["noise"]["force_std"],\n            config["noise"]["torque_std"]\n        ])\n        noise = np.random.normal(0, noise_std)\n\n        # Add bias\n        measured_wrench = true_wrench + noise + sensor["bias"]\n\n        # Apply temperature drift if temperature provided\n        if temperature is not None:\n            temp_diff = temperature - sensor["temperature"]\n            force_drift = measured_wrench[:3] * (config["temperature_drift"]["force_ppm_per_celsius"] * 1e-6 * temp_diff)\n            torque_drift = measured_wrench[3:] * (config["temperature_drift"]["torque_ppm_per_celsius"] * 1e-6 * temp_diff)\n            measured_wrench[:3] += force_drift\n            measured_wrench[3:] += torque_drift\n\n        # Apply range limits\n        force_limits = np.array(config["measurement_range"]["force"])\n        torque_limits = np.array(config["measurement_range"]["torque"])\n        limits = np.concatenate([force_limits, torque_limits])\n\n        measured_wrench = np.clip(measured_wrench, -limits, limits)\n\n        # Update sensor state\n        sensor["temperature"] = temperature if temperature is not None else sensor["temperature"]\n        sensor["last_update"] += dt\n\n        return measured_wrench\n\n    def get_sensor_data(self, sensor_name):\n        """Get the latest sensor data"""\n        if sensor_name not in self.sensors:\n            return None\n\n        # In a real implementation, this would return the last simulated reading\n        # For now, return the sensor configuration\n        return {\n            "name": self.sensors[sensor_name]["name"],\n            "configuration": self.sensors[sensor_name]["config"],\n            "bias": self.sensors[sensor_name]["bias"],\n            "temperature": self.sensors[sensor_name]["temperature"]\n        }\n'})}),"\n",(0,t.jsx)(e.h2,{id:"96-integration-with-ros-2",children:"9.6 Integration with ROS 2"}),"\n",(0,t.jsx)(e.h3,{id:"961-isaac-sim-ros-bridge-configuration",children:"9.6.1 Isaac Sim ROS Bridge Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# ROS 2 bridge configuration for Isaac Sim\nros_bridge_config = {\n    "ros_bridge_settings": {\n        "bridge_type": "omni.isaac.ros_bridge",\n        "topic_prefix": "/humanoid_robot",\n        "frame_prefix": "humanoid/",\n        "qos_settings": {\n            "sensor_data": {\n                "history": "keep_last",\n                "depth": 1,\n                "reliability": "best_effort",\n                "durability": "volatile"\n            },\n            "control_commands": {\n                "history": "keep_last",\n                "depth": 10,\n                "reliability": "reliable",\n                "durability": "volatile"\n            },\n            "state_data": {\n                "history": "keep_last",\n                "depth": 10,\n                "reliability": "reliable",\n                "durability": "transient_local"\n            }\n        }\n    },\n    "sensor_topic_mapping": {\n        "cameras": {\n            "rgb": {\n                "topic": "/head/rgb_camera/image_rect_color",\n                "type": "sensor_msgs/msg/Image",\n                "frequency": 30\n            },\n            "depth": {\n                "topic": "/head/depth_camera/image_rect_raw",\n                "type": "sensor_msgs/msg/Image",\n                "frequency": 30\n            },\n            "camera_info": {\n                "topic": "/head/rgb_camera/camera_info",\n                "type": "sensor_msgs/msg/CameraInfo",\n                "frequency": 30\n            }\n        },\n        "imu": {\n            "primary": {\n                "topic": "/torso/imu/data",\n                "type": "sensor_msgs/msg/Imu",\n                "frequency": 100\n            },\n            "secondary": {\n                "topic": "/head/imu/data",\n                "type": "sensor_msgs/msg/Imu",\n                "frequency": 100\n            }\n        },\n        "force_torque": {\n            "left_foot": {\n                "topic": "/left_foot/force_torque",\n                "type": "geometry_msgs/msg/WrenchStamped",\n                "frequency": 1000\n            },\n            "right_foot": {\n                "topic": "/right_foot/force_torque",\n                "type": "geometry_msgs/msg/WrenchStamped",\n                "frequency": 1000\n            },\n            "left_hand": {\n                "topic": "/left_hand/force_torque",\n                "type": "geometry_msgs/msg/WrenchStamped",\n                "frequency": 1000\n            },\n            "right_hand": {\n                "topic": "/right_hand/force_torque",\n                "type": "geometry_msgs/msg/WrenchStamped",\n                "frequency": 1000\n            }\n        },\n        "joint_state": {\n            "topic": "/joint_states",\n            "type": "sensor_msgs/msg/JointState",\n            "frequency": 100\n        }\n    },\n    "control_topic_mapping": {\n        "joint_commands": {\n            "position": {\n                "topic": "/position_commands",\n                "type": "std_msgs/msg/Float64MultiArray",\n                "frequency": 100\n            },\n            "velocity": {\n                "topic": "/velocity_commands",\n                "type": "std_msgs/msg/Float64MultiArray",\n                "frequency": 100\n            },\n            "effort": {\n                "topic": "/effort_commands",\n                "type": "std_msgs/msg/Float64MultiArray",\n                "frequency": 100\n            }\n        },\n        "navigation": {\n            "goal_pose": {\n                "topic": "/goal_pose",\n                "type": "geometry_msgs/msg/PoseStamped",\n                "frequency": 10\n            },\n            "cmd_vel": {\n                "topic": "/cmd_vel",\n                "type": "geometry_msgs/msg/Twist",\n                "frequency": 50\n            }\n        }\n    }\n}\n\n# Example ROS 2 node for Isaac Sim integration\nclass IsaacSimROSInterface:\n    """Interface between Isaac Sim and ROS 2"""\n\n    def __init__(self, node_name="isaac_sim_interface"):\n        # In Isaac Sim, we use their ROS bridge extensions\n        # This is a conceptual implementation showing how the interface would work\n        self.node_name = node_name\n        self.isaac_sim_initialized = False\n\n    def initialize_isaac_sim_bridge(self):\n        """Initialize the Isaac Sim ROS bridge"""\n        # In practice, this would involve:\n        # 1. Loading the omni.isaac.ros_bridge extension\n        # 2. Setting up the bridge configuration\n        # 3. Mapping Isaac Sim topics to ROS 2 topics\n        print("Initializing Isaac Sim ROS bridge...")\n\n        # This would typically be done in Isaac Sim\'s extension system\n        # For demonstration purposes:\n        self.isaac_sim_initialized = True\n        print("Isaac Sim ROS bridge initialized successfully")\n\n    def create_sensor_publishers(self, sensor_config):\n        """Create ROS publishers for Isaac Sim sensors"""\n        # In Isaac Sim, sensors automatically publish to ROS topics\n        # when the ROS bridge is configured properly\n        print("Setting up sensor publishing through Isaac Sim bridge...")\n\n        # The actual setup would be done in USD files or through Isaac Sim\'s API\n        for sensor_type, sensor_info in sensor_config.items():\n            print(f"  Configured {sensor_type} sensor publishing to {sensor_info[\'topic\']}")\n\n    def create_control_subscribers(self, control_config):\n        """Create ROS subscribers for Isaac Sim control"""\n        # In Isaac Sim, control commands are automatically subscribed\n        # when the ROS bridge is configured properly\n        print("Setting up control subscription through Isaac Sim bridge...")\n\n        # The actual setup would be done in USD files or through Isaac Sim\'s API\n        for control_type, control_info in control_config.items():\n            print(f"  Configured {control_type} control subscription from {control_info[\'topic\']}")\n\n    def synchronize_simulation_clock(self):\n        """Synchronize Isaac Sim clock with ROS clock"""\n        # Isaac Sim can publish clock messages to synchronize with ROS\n        print("Clock synchronization enabled")\n'})})]})}function _(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(m,{...n})}):m(n)}}}]);